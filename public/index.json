[{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is a first in a series of posts where I\u0026rsquo;ll describe my setup in all 3 languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to write other than \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geard towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version accross all my project - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the 2 most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LPS, formatting) Language server features of Go are provided by gopls (shipps with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code - although I mostly call it with a keyboard shortcut for the file I am working on in IDE.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from the said library as well (I came to Go from python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nShipping ","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is a first in a series of posts where I\u0026rsquo;ll describe my setup in all 3 languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to write other than \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is a first in a series of posts where I\u0026rsquo;ll describe my setup in all 3 languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to write other than \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geard towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version accross all my project - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the 2 most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LPS, formatting) Language server features of Go are provided by gopls (shipps with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code - although I mostly call it with a keyboard shortcut for the file I am working on in IDE.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from the said library as well (I came to Go from python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nShipping Building code is as easy as runing\ngo build ./... ","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is a first in a series of posts where I\u0026rsquo;ll describe my setup in all 3 languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to write other than \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is a first in a series of posts where I\u0026rsquo;ll describe my setup in all 3 languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to write other than \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geard towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version accross all my project - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the 2 most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LPS, formatting) Language server features of Go are provided by gopls (shipps with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code - although I mostly call it with a keyboard shortcut for the file I am working on in IDE.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from the said library as well (I came to Go from python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nShipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was build on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM WORKDIR /app COPY internal /app/internal ADD cmd /app/cmd ADD db /app/db ADD spicedb /app/spicedb COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . RUN GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2); wget -O /go/bin/grpc_health_probe https://github.com/grpc-ecosystem/grpc-health-probe/releases/download/v0.4.21/grpc_health_probe-linux-${GOARCH} RUN chmod +x /go/bin/grpc_health_probe FROM tarampampam/curl:8.2.1 AS curl FROM gcr.io/distroless/static-debian11 AS base USER nonroot # These dependencies are needed for the health check COPY --from=curl --chown=nonroot:nonroot /bin/curl /bin/curl COPY --from=build --chown=nonroot:nonroot /go/bin/grpc_health_probe /bin/grpc-health-probe COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] ","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is a first in a series of posts where I\u0026rsquo;ll describe my setup in all 3 languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to write other than \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is a first in a series of posts where I\u0026rsquo;ll describe my setup in all 3 languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to write other than \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geard towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version accross all my project - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the 2 most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LPS, formatting) Language server features of Go are provided by gopls (shipps with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code - although I mostly call it with a keyboard shortcut for the file I am working on in IDE.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from the said library as well (I came to Go from python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nShipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was build on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build WORKDIR /app COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot # These dependencies are needed for the health check COPY --from=curl --chown=nonroot:nonroot /bin/curl /bin/curl COPY --from=build --chown=nonroot:nonroot /go/bin/grpc_health_probe /bin/grpc-health-probe COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] ","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is a first in a series of posts where I\u0026rsquo;ll describe my setup in all 3 languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to write other than \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is a first in a series of posts where I\u0026rsquo;ll describe my setup in all 3 languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to write other than \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geard towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version accross all my project - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the 2 most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LPS, formatting) Language server features of Go are provided by gopls (shipps with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code - although I mostly call it with a keyboard shortcut for the file I am working on in IDE.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from the said library as well (I came to Go from python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nShipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was build on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] Here\n","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is a first in a series of posts where I\u0026rsquo;ll describe my setup in all 3 languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to write other than \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is a first in a series of posts where I\u0026rsquo;ll describe my setup in all 3 languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to write other than \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geard towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version accross all my project - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the 2 most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LPS, formatting) Language server features of Go are provided by gopls (shipps with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code - although I mostly call it with a keyboard shortcut for the file I am working on in IDE.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from the said library as well (I came to Go from python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nShipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was build on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] Docker requires you to specify the target platform as linux/arm64 or linux/amd64, which is the use of cut is needed.\n","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is a first in a series of posts where I\u0026rsquo;ll describe my setup in all 3 languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to write other than \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is a first in a series of posts where I\u0026rsquo;ll describe my setup in all 3 languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to write other than \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geard towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version accross all my project - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the 2 most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LPS, formatting) Language server features of Go are provided by gopls (shipps with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code - although I mostly call it with a keyboard shortcut for the file I am working on in IDE.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from the said library as well (I came to Go from python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nShipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was build on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] Docker requires you to specify the target platform as linux/arm64 or linux/amd64, while Go omites the linux/ prefix, which is the use of cut is needed.\n","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is a first in a series of posts where I\u0026rsquo;ll describe my setup in all 3 languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to write other than \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is a first in a series of posts where I\u0026rsquo;ll describe my setup in all 3 languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to write other than \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geard towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version accross all my project - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the 2 most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LPS, formatting) Language server features of Go are provided by gopls (shipps with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code - although I mostly call it with a keyboard shortcut for the file I am working on in IDE.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from the said library as well (I came to Go from python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nShipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was build on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] Docker requires you to specify the target platform as linux/arm64 or linux/amd64, while Go omits the linux/ prefix, which is the use of cut is needed.\n","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is a first in a series of posts where I\u0026rsquo;ll describe my setup in all 3 languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to write other than \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to write other than \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geard towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version accross all my project - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the 2 most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LPS, formatting) Language server features of Go are provided by gopls (shipps with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code - although I mostly call it with a keyboard shortcut for the file I am working on in IDE.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from the said library as well (I came to Go from python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nShipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was build on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] Docker requires you to specify the target platform as linux/arm64 or linux/amd64, while Go omits the linux/ prefix, which is the use of cut is needed.\n","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to write other than \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geard towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version accross all my project - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the 2 most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LPS, formatting) Language server features of Go are provided by gopls (shipps with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code - although I mostly call it with a keyboard shortcut for the file I am working on in IDE.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from the said library as well (I came to Go from python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nShipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was build on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] Docker requires you to specify the target platform as linux/arm64 or linux/amd64, while Go omits the linux/ prefix, which is the use of cut is needed.\n","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geared towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version accross all my project - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the 2 most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LPS, formatting) Language server features of Go are provided by gopls (shipps with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code - although I mostly call it with a keyboard shortcut for the file I am working on in IDE.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from the said library as well (I came to Go from python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nShipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was build on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] Docker requires you to specify the target platform as linux/arm64 or linux/amd64, while Go omits the linux/ prefix, which is the use of cut is needed.\n","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geared towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest Go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version accross all my project - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the 2 most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LPS, formatting) Language server features of Go are provided by gopls (shipps with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code - although I mostly call it with a keyboard shortcut for the file I am working on in IDE.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from the said library as well (I came to Go from python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nShipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was build on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] Docker requires you to specify the target platform as linux/arm64 or linux/amd64, while Go omits the linux/ prefix, which is the use of cut is needed.\n","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geared towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest Go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version across all my projects - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the 2 most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LPS, formatting) Language server features of Go are provided by gopls (shipps with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code - although I mostly call it with a keyboard shortcut for the file I am working on in IDE.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from the said library as well (I came to Go from python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nShipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was build on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] Docker requires you to specify the target platform as linux/arm64 or linux/amd64, while Go omits the linux/ prefix, which is the use of cut is needed.\n","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geared towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest Go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version across all my projects - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the two most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LPS, formatting) Language server features of Go are provided by gopls (shipps with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code - although I mostly call it with a keyboard shortcut for the file I am working on in IDE.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from the said library as well (I came to Go from python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nShipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was build on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] Docker requires you to specify the target platform as linux/arm64 or linux/amd64, while Go omits the linux/ prefix, which is the use of cut is needed.\n","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geared towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest Go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version across all my projects - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the two most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LPS, formatting) Language server features of Go are provided by gopls (ships with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code - although I mostly call it with a keyboard shortcut for the file I am working on in IDE.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from the said library as well (I came to Go from python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nShipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was build on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] Docker requires you to specify the target platform as linux/arm64 or linux/amd64, while Go omits the linux/ prefix, which is the use of cut is needed.\n","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geared towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest Go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version across all my projects - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the two most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LPS, formatting) Language server features of Go are provided by gopls (ships with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code—although I mostly call it with a keyboard shortcut in the IDE for the file I’m working on.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from the said library as well (I came to Go from python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nShipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was build on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] Docker requires you to specify the target platform as linux/arm64 or linux/amd64, while Go omits the linux/ prefix, which is the use of cut is needed.\n","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geared towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest Go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version across all my projects - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the two most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LPS, formatting) Language server features of Go are provided by gopls (ships with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code—although I mostly call it with a keyboard shortcut in the IDE for the file I’m working on.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from this library as well (I came to Go from Python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nShipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was built on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] Docker requires you to specify the target platform as linux/arm64 or linux/amd64, while Go omits the linux/ prefix, which is the use of cut is needed.\n","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geared towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest Go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version across all my projects - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the two most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LPS, formatting) Language server features of Go are provided by gopls (ships with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code—although I mostly call it with a keyboard shortcut in the IDE for the file I’m working on.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from this library as well (I came to Go from Python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nShipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was built on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] Docker requires you to specify the target platform as linux/arm64 or linux/amd64, while Go omits the linux/ prefix, which is why the use of cut is needed.\n","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geared towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest Go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version across all my projects - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the two most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LSP, formatting) Language server features of Go are provided by gopls (ships with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code—although I mostly call it with a keyboard shortcut in the IDE for the file I’m working on.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from this library as well (I came to Go from Python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nShipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was built on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] Docker requires you to specify the target platform as linux/arm64 or linux/amd64, while Go omits the linux/ prefix, which is why the use of cut is needed.\n","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geared towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest Go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version across all my projects - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the two most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LSP, formatting) Language server features of Go are provided by gopls (ships with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code—although I mostly call it with a keyboard shortcut in the IDE for the file I’m working on.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from this library as well (I came to Go from Python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nShipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was built on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] Docker requires you to specify the target platform as linux/arm64 or linux/amd64, while Go omits the linux/ prefix, which is why the use of cut is needed.\n","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geared towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest Go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version across all my projects - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the two most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LSP, formatting) Language server features of Go are provided by gopls (ships with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code—although I mostly call it with a keyboard shortcut in the IDE for the file I’m working on.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from this library as well (I came to Go from Python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nShipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was built on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] Docker requires you to specify the target platform as linux/arm64 or linux/amd64, while Go omits the linux/ prefix, which is why the use of cut is needed.\n","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geared towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest Go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version across all my projects - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the two most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LSP, formatting) Language server features of Go are provided by gopls (ships with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code—although I mostly call it with a keyboard shortcut in the IDE for the file I’m working on.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from this library as well (I came to Go from Python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nHere\u0026rsquo;s an example test file that uses all of the things mentioned:\npackage db_test import ( \u0026#34;os\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;github.com/stretchr/testify/assert\u0026#34; \u0026#34;myrepo/fakedb\u0026#34; // Example placeholder ) // Global DB connection. var dbConn *fakedb.Connection func TestMain(m *testing.M) { // === SETUP PHASE === // Initialize and open the database connection. dbConn = fakedb.NewConnection(\u0026#34;fakedb://localhost:5432\u0026#34;) if err := dbConn.Open(); err != nil { // If we can\u0026#39;t open the DB, exit immediately. os.Exit(1) } // Run all tests. exitCode := m.Run() // === TEARDOWN PHASE === // Close the connection, clean up resources. dbConn.Close() // Exit with the test run\u0026#39;s code. os.Exit(exitCode) } func TestInsertAndQueryUser(t *testing.T) { // Insert a user row. err := dbConn.Insert(\u0026#34;users\u0026#34;, map[string]interface{}{ \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, }) assert.NoError(t, err, \u0026#34;Insert should succeed\u0026#34;) // Query the user row. rows, err := dbConn.Query(\u0026#34;SELECT name FROM users WHERE id = 1\u0026#34;) assert.NoError(t, err, \u0026#34;Query should succeed\u0026#34;) // Check that exactly one row is returned, and the data is correct. assert.Len(t, rows, 1) assert.Equal(t, \u0026#34;Alice\u0026#34;, rows[0][\u0026#34;name\u0026#34;]) } Shipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was built on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] Docker requires you to specify the target platform as linux/arm64 or linux/amd64, while Go omits the linux/ prefix, which is why the use of cut is needed.\n","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geared towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest Go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version across all my projects - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the two most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LSP, formatting) Language server features of Go are provided by gopls (ships with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code—although I mostly call it with a keyboard shortcut in the IDE for the file I’m working on.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from this library as well (I came to Go from Python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nHere\u0026rsquo;s an example test file that uses all of the things mentioned:\npackage db_test import ( \u0026#34;os\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;github.com/stretchr/testify/assert\u0026#34; \u0026#34;myrepo/fakedb\u0026#34; ) // Global DB connection. var dbConn *fakedb.Connection func TestMain(m *testing.M) { // Initialize and open the database connection. dbConn = fakedb.NewConnection(\u0026#34;fakedb://localhost:5432\u0026#34;) if err := dbConn.Open(); err != nil { os.Exit(1) // If we can\u0026#39;t open the DB, exit immediately. } // Run all tests. m.Run() // Close the connection, clean up resources. dbConn.Close() } func TestInsertUser(t *testing.T) { err := dbConn.Insert(\u0026#34;users\u0026#34;, map[string]interface{}{ \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, }) assert.NoError(t, err, \u0026#34;Insert should succeed\u0026#34;) // Query the user row. rows, err := dbConn.Query(\u0026#34;SELECT name FROM users WHERE id = 1\u0026#34;) assert.NoError(t, err, \u0026#34;Query should succeed\u0026#34;) // Check that exactly one row is returned, and the data is correct. assert.Len(t, rows, 1) assert.Equal(t, \u0026#34;Alice\u0026#34;, rows[0][\u0026#34;name\u0026#34;]) } Shipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was built on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] Docker requires you to specify the target platform as linux/arm64 or linux/amd64, while Go omits the linux/ prefix, which is why the use of cut is needed.\n","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geared towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest Go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version across all my projects - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the two most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LSP, formatting) Language server features of Go are provided by gopls (ships with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code—although I mostly call it with a keyboard shortcut in the IDE for the file I’m working on.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks. For example, using t.Cleanup to clean up resources after a test. If doing tests on a database, you might want to isolate tests from one another either by injecting a transaction that gets rolled back at the end of the test, or by re-creating database from a template for each test. Describing these techniques in details would require it own post - here\u0026rsquo;s a nice repo with examples and a video (in Russian) that go into much more detail.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from this library as well (I came to Go from Python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nHere\u0026rsquo;s an example test file that uses all of the things mentioned:\npackage db_test import ( \u0026#34;os\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;github.com/stretchr/testify/assert\u0026#34; \u0026#34;myrepo/fakedb\u0026#34; ) // Global DB connection. var dbConn *fakedb.Connection func TestMain(m *testing.M) { // Initialize and open the database connection. dbConn = fakedb.NewConnection(\u0026#34;fakedb://localhost:5432\u0026#34;) if err := dbConn.Open(); err != nil { os.Exit(1) // If we can\u0026#39;t open the DB, exit immediately. } // Run all tests. m.Run() // Close the connection, clean up resources. dbConn.Close() } func TestInsertUser(t *testing.T) { err := dbConn.Insert(\u0026#34;users\u0026#34;, map[string]interface{}{ \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, }) assert.NoError(t, err, \u0026#34;Insert should succeed\u0026#34;) // Query the user row. rows, err := dbConn.Query(\u0026#34;SELECT name FROM users WHERE id = 1\u0026#34;) assert.NoError(t, err, \u0026#34;Query should succeed\u0026#34;) // Check that exactly one row is returned, and the data is correct. assert.Len(t, rows, 1) assert.Equal(t, \u0026#34;Alice\u0026#34;, rows[0][\u0026#34;name\u0026#34;]) } Shipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was built on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] Docker requires you to specify the target platform as linux/arm64 or linux/amd64, while Go omits the linux/ prefix, which is why the use of cut is needed.\n","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geared towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest Go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version across all my projects - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the two most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LSP, formatting) Language server features of Go are provided by gopls (ships with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code—although I mostly call it with a keyboard shortcut in the IDE for the file I’m working on.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks. For example, using t.Cleanup to clean up resources after a test.\nIf doing tests on a database, you might want to isolate tests from one another either by injecting a transaction that gets rolled back at the end of the test, or by re-creating database from a template for each test. Describing these techniques in details would require it own post - here\u0026rsquo;s a nice repo with examples and a video (in Russian) that go into much more detail.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from this library as well (I came to Go from Python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nHere\u0026rsquo;s an example test file that uses all of the things mentioned:\npackage db_test import ( \u0026#34;os\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;github.com/stretchr/testify/assert\u0026#34; \u0026#34;myrepo/fakedb\u0026#34; ) // Global DB connection. var dbConn *fakedb.Connection func TestMain(m *testing.M) { // Initialize and open the database connection. dbConn = fakedb.NewConnection(\u0026#34;fakedb://localhost:5432\u0026#34;) if err := dbConn.Open(); err != nil { os.Exit(1) // If we can\u0026#39;t open the DB, exit immediately. } // Run all tests. m.Run() // Close the connection, clean up resources. dbConn.Close() } func TestInsertUser(t *testing.T) { err := dbConn.Insert(\u0026#34;users\u0026#34;, map[string]interface{}{ \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, }) assert.NoError(t, err, \u0026#34;Insert should succeed\u0026#34;) // Query the user row. rows, err := dbConn.Query(\u0026#34;SELECT name FROM users WHERE id = 1\u0026#34;) assert.NoError(t, err, \u0026#34;Query should succeed\u0026#34;) // Check that exactly one row is returned, and the data is correct. assert.Len(t, rows, 1) assert.Equal(t, \u0026#34;Alice\u0026#34;, rows[0][\u0026#34;name\u0026#34;]) } Shipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was built on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] Docker requires you to specify the target platform as linux/arm64 or linux/amd64, while Go omits the linux/ prefix, which is why the use of cut is needed.\n","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geared towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest Go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version across all my projects - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the two most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LSP, formatting) Language server features of Go are provided by gopls (ships with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code—although I mostly call it with a keyboard shortcut in the IDE for the file I’m working on.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks. For example, using t.Cleanup to clean up resources after a test.\nIf doing tests on a database, you might want to isolate tests from one another either by injecting a transaction that gets rolled back at the end of the test, or by re-creating database from a template for each test. Describing these techniques in details would require it own post - here\u0026rsquo;s a nice repo with examples and a video (in Russian) that go into much more detail.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from this library as well (I came to Go from Python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nHere\u0026rsquo;s an example test file that uses some of the things mentioned above:\npackage db_test import ( \u0026#34;os\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;github.com/stretchr/testify/assert\u0026#34; \u0026#34;myrepo/fakedb\u0026#34; ) // Global DB connection. var dbConn *fakedb.Connection func TestMain(m *testing.M) { // Initialize and open the database connection. dbConn = fakedb.NewConnection(\u0026#34;fakedb://localhost:5432\u0026#34;) if err := dbConn.Open(); err != nil { os.Exit(1) // If we can\u0026#39;t open the DB, exit immediately. } // Run all tests. m.Run() // Close the connection, clean up resources. dbConn.Close() } func TestInsertUser(t *testing.T) { err := dbConn.Insert(\u0026#34;users\u0026#34;, map[string]interface{}{ \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, }) assert.NoError(t, err, \u0026#34;Insert should succeed\u0026#34;) // Query the user row. rows, err := dbConn.Query(\u0026#34;SELECT name FROM users WHERE id = 1\u0026#34;) assert.NoError(t, err, \u0026#34;Query should succeed\u0026#34;) // Check that exactly one row is returned, and the data is correct. assert.Len(t, rows, 1) assert.Equal(t, \u0026#34;Alice\u0026#34;, rows[0][\u0026#34;name\u0026#34;]) } Shipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was built on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] Docker requires you to specify the target platform as linux/arm64 or linux/amd64, while Go omits the linux/ prefix, which is why the use of cut is needed.\n","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geared towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest Go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version across all my projects - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the two most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LSP, formatting) Language server features of Go are provided by gopls (ships with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code—although I mostly call it with a keyboard shortcut in the IDE for the file I’m working on.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks. For example, using t.Cleanup to clean up resources after a test.\nIf doing tests on a database, you might want to isolate tests from one another either by injecting a transaction that gets rolled back at the end of the test, or by re-creating database from a template for each test. Describing these techniques in details would require it own post - here\u0026rsquo;s a nice repo with examples and a video (in Russian) that go into much more detail.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from this library as well (I came to Go from Python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nHere\u0026rsquo;s an example test file that uses some of the things mentioned above:\npackage db_test import ( \u0026#34;os\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;github.com/stretchr/testify/assert\u0026#34; \u0026#34;myrepo/fakedb\u0026#34; ) // Global DB connection. var dbConn *fakedb.Connection // setupUsersTable is a helper function that creates the \u0026#39;users\u0026#39; table // and schedules it to be dropped after the test completes. func setupUsersTable(t *testing.T) { err := dbConn.Exec(\u0026#34;CREATE TABLE users (id INT, name TEXT)\u0026#34;) if err != nil { t.Fatalf(\u0026#34;failed to create table: %v\u0026#34;, err) } t.Cleanup(func() { _ = dbConn.Exec(\u0026#34;DROP TABLE users\u0026#34;) }) } func TestMain(m *testing.M) { // Initialize and open the database connection. dbConn = fakedb.NewConnection(\u0026#34;fakedb://localhost:5432\u0026#34;) if err := dbConn.Open(); err != nil { os.Exit(1) // If we can\u0026#39;t open the DB, exit immediately. } // Run all tests. m.Run() // Close the connection, clean up resources. dbConn.Close() } func TestInsertUser(t *testing.T) { err := dbConn.Insert(\u0026#34;users\u0026#34;, map[string]interface{}{ \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, }) assert.NoError(t, err, \u0026#34;Insert should succeed\u0026#34;) // Query the user row. rows, err := dbConn.Query(\u0026#34;SELECT name FROM users WHERE id = 1\u0026#34;) assert.NoError(t, err, \u0026#34;Query should succeed\u0026#34;) // Check that exactly one row is returned, and the data is correct. assert.Len(t, rows, 1) assert.Equal(t, \u0026#34;Alice\u0026#34;, rows[0][\u0026#34;name\u0026#34;]) } Shipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was built on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] Docker requires you to specify the target platform as linux/arm64 or linux/amd64, while Go omits the linux/ prefix, which is why the use of cut is needed.\n","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"},{"content":"I\u0026rsquo;m participating in this year\u0026rsquo;s Advent of Code writing solutions in all 3 languages I am proficient in: Python, Go and C++.\nI came across an interesting solution to the Day 9 problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\nThe problem You have some disk space, which is populated by files, with some empty space between them:\n00...111...2...333.44.5555.6666.777.888899 The numbers represent files, a group of equal numbers here is a single file, and dots are empty space. In the first part, you\u0026rsquo;re supposed to move files into the empty space (starting with the rightmost file), splitting the file between multiple empty spaces if needed. Here\u0026rsquo;s how the process looks like:\n00...111...2...333.44.5555.6666.777.888899 009..111...2...333.44.5555.6666.777.88889. 0099.111...2...333.44.5555.6666.777.8888.. 00998111...2...333.44.5555.6666.777.888... 009981118..2...333.44.5555.6666.777.88.... 0099811188.2...333.44.5555.6666.777.8..... 009981118882...333.44.5555.6666.777....... 0099811188827..333.44.5555.6666.77........ 00998111888277.333.44.5555.6666.7......... 009981118882777333.44.5555.6666........... 009981118882777333644.5555.666............ 00998111888277733364465555.66............. 0099811188827773336446555566.............. In part 2, you can only move a file to an empty space if the whole file fits into it - no file splitting allowed. The process looks like this:\n00...111...2...333.44.5555.6666.777.888899 0099.111...2...333.44.5555.6666.777.8888.. 0099.1117772...333.44.5555.6666.....8888.. 0099.111777244.333....5555.6666.....8888.. 00992111777.44.333....5555.6666.....8888.. You\u0026rsquo;ll notice that the files are numbered - these numbers are needed to compute a checksum at the end, to verify that the result is correct.\nThe solution In part 1, the solution is straightforward - you just fill empty spaces until the entire file is moved. To acheive an efficient solution, you have to track the index of the leftmost empty space available (in my solution empty_space_ind), so you don\u0026rsquo;t have to loop from the beginning for each file.\nFor the first part you can represent the files and empty space either as single bytes on the line, or as blocks. I chose blocks (each block having a start, length and index attribute). Here\u0026rsquo;s the core of the solution - the part that moves the files in the empty spaces:\nempty_space_ind = 1 for file_ind in range(len(spaces) - 1, -1, -2): file = spaces[file_ind] while file_ind \u0026gt; empty_space_ind and file.length \u0026gt; 0: empty = spaces[empty_space_ind] if empty.length \u0026gt; file.length: # We\u0026#39;ve moved the entire file file.start = empty.start empty.start += file.length empty.length -= file.length break # We completely fill this empty space empty.index = file.index file.length -= empty.length empty_space_ind += 2 For part 2, we can only move a file, if there is an empty space at least as large as itself. This means that we may skip over some empty spaces that are not large enough - however those empty spaces are still available, and may be filled later by a smaller file.\nThis prevents us from tracking the leftmost available empty space, so it seems that for each file, we must loop over all empty spaces from the beginning. Here\u0026rsquo;s how this would look in code:\nfor i in range(len(files) - 1, -1, -1): file = files[i] for j in range(len(empties)): empty = empties[j] if empty.start \u0026gt; file.start: break if empty.length \u0026lt; file.length: continue file.start = empty.start empty.start += file.length empty.length -= file.length break This solution was fast enough (takes about a second in python, and feels instantaneous in C++), so I didn\u0026rsquo;t explore any further optimizations. However, when looking at others\u0026rsquo; solutions in a reddit thread, I came upon a solution that optimized away this inefficient foor loop in part 2.\nThe optimized solution The solution by maneatingape (written in Rust, btw) uses an array of min heaps to store the leftmost available empty spaces.\n// Build a min-heap (leftmost free block first) where the size of each block is // implicit in the index of the array. for (index, \u0026amp;size) in disk.iter().enumerate() { if index % 2 == 1 \u0026amp;\u0026amp; size \u0026gt; 0 { free[size].push(block); } block += size; } // ... for (index, \u0026amp;size) in disk.iter().enumerate().rev() { //... // Find the leftmost free block that can fit the file (if any). let mut next_block = block; let mut next_index = usize::MAX; for (i, heap) in free.iter().enumerate().skip(size) { let top = heap.len() - 1; let first = heap[top]; if first \u0026lt; next_block { next_block = first; next_index = i; } } Here\u0026rsquo;s how this works: the length of files/empty spaces can be no longer than 9. So we simply store available empty spaces for each of the 9 possible lengths! So when we need to place a file with size $S$ in an empty space, we check all empty spaces with size $\\geq S$, and take the leftmost available space.\nMin heaps are used to store the empty spaces, so that we always have the leftmost available. As there are 9 possible lengths - we just create an array of 9 min heaps.\nThis certainly is not a super advanced algorithm, but the usage of array of min heaps did strike me as quite clever. I don\u0026rsquo;t remember seeing more than one or two heaps used in a solution.\n","permalink":"http://localhost:1313/bits/aoc-2024-day-9/","summary":"\u003cp\u003eI\u0026rsquo;m \u003ca href=\"https://github.com/tadejsv/aoc-2024\"\u003eparticipating\u003c/a\u003e in this year\u0026rsquo;s \u003ca href=\"https://adventofcode.com/2024\"\u003eAdvent of Code\u003c/a\u003e writing solutions in all 3 languages I am proficient in: Python, Go and C++.\u003c/p\u003e\n\u003cp\u003eI came across an interesting solution to the \u003ca href=\"https://adventofcode.com/2024/day/9\"\u003eDay 9\u003c/a\u003e problem. This is still one of the earlier days, so you\u0026rsquo;re not supposed to pull out the big guns (fancy algos) just yet. Nevertheless, this solution (which I\u0026rsquo;ll get to in just a minute) made an interesting use of min heaps to acheive a substantial speedup on part 2 of the problem.\u003c/p\u003e","title":"AOC 2024 Day 9: A clever use of heaps"},{"content":"In this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; Go code. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\nThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\nI code in VSCode, so my setup is geared towards it.\nEnvironment managament I\u0026rsquo;m lucky I don\u0026rsquo;t have to think about setting up an \u0026ldquo;environment\u0026rdquo; for Go at all - I just install the latest Go binary, navigate to the directory where I want to set up a project, and do\ngo mod init \u0026lt;project_name\u0026gt; That\u0026rsquo;s it. The only potential downside is that this way I am bound to the latest Go version across all my projects - but given Go\u0026rsquo;s strong dedication to backward compatibility, this is not an issue.\nThis \u0026ldquo;guarantee\u0026rdquo; also contributes to the established practice in Go community of only supporting the two most recent minor versions of the language - as it is always safe to upgrade, there is no reason anyone would need support for an older version of the language.\nPackage management Here I can also relax and just use Go\u0026rsquo;s default package manager (modules). I don\u0026rsquo;t think anything else exists.\nUpdating all packages is easy:\ngo get -u I like to follow that up with go mod tidy to clean up go.sum.\nIDE integration (LSP, formatting) Language server features of Go are provided by gopls (ships with Go binary), and managed by the official Go VSCode extension. Everything works as it should - you can see object types, function signatures when hovering over code.\ngo fmt is used for formatting code—although I mostly call it with a keyboard shortcut in the IDE for the file I’m working on.\nDebugging I haven\u0026rsquo;t yet needed to use a debugger in Go - if I ever will, I will use delve.\nLinting I use golangci-lint - it\u0026rsquo;s a lint runner that runs a bunch of different linters, all specified in a single config file. Due to a large number of linters run, it takes a while to run (~20s). In VSCode I use it with the --fast flag, I only run the full version before committing and in CI.\nTesting Go standard library testing package is great! Amazing support for all kinds of tests and benchmarking. Although to be able to fully exploit its capabilities you need to learn a few tricks. For example, using t.Cleanup to clean up resources after a test.\nIf doing tests on a database, you might want to isolate tests from one another either by injecting a transaction that gets rolled back at the end of the test, or by re-creating database from a template for each test. Describing these techniques in details would require it own post - here\u0026rsquo;s a nice repo with examples and a video (in Russian) that go into much more detail.\nOh and, I use the testify library for assert statements. I really think it should be part of the standard library.\nI used to heavily rely on TestSuite from this library as well (I came to Go from Python, and using a test suite was as close to writing tests a-la pytest as I could get), but have since torn it out and replaced it with TestMain and a few judiciously placed global variables.\nHere\u0026rsquo;s an example test file that uses some of the things mentioned above:\npackage db_test import ( \u0026#34;os\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;github.com/stretchr/testify/assert\u0026#34; \u0026#34;myrepo/fakedb\u0026#34; ) // Global DB connection. var dbConn *fakedb.Connection // setupUsersTable is a helper function that creates the \u0026#39;users\u0026#39; table // and schedules it to be dropped after the test completes. func setupUsersTable(t *testing.T) { t.Helper() err := dbConn.Exec(\u0026#34;CREATE TABLE users (id INT, name TEXT)\u0026#34;) if err != nil { t.Fatalf(\u0026#34;failed to create table: %v\u0026#34;, err) } t.Cleanup(func() { _ = dbConn.Exec(\u0026#34;DROP TABLE users\u0026#34;) }) } func TestMain(m *testing.M) { // Initialize and open the database connection. dbConn = fakedb.NewConnection(\u0026#34;fakedb://localhost:5432\u0026#34;) if err := dbConn.Open(); err != nil { os.Exit(1) // If we can\u0026#39;t open the DB, exit immediately. } // Run all tests. m.Run() // Close the connection, clean up resources. dbConn.Close() } func TestInsertUser(t *testing.T) { setupUsersTable(t) err := dbConn.Insert(\u0026#34;users\u0026#34;, map[string]interface{}{ \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, }) assert.NoError(t, err, \u0026#34;Insert should succeed\u0026#34;) // Query the user row. rows, err := dbConn.Query(\u0026#34;SELECT name FROM users WHERE id = 1\u0026#34;) assert.NoError(t, err, \u0026#34;Query should succeed\u0026#34;) // Check that exactly one row is returned, and the data is correct. assert.Len(t, rows, 1) assert.Equal(t, \u0026#34;Alice\u0026#34;, rows[0][\u0026#34;name\u0026#34;]) } Shipping Building code is as easy as runing\ngo build ./... I ship go binaries in docker containers. Since the binary is pretty much the only thing required for the application to run, I use the minimal distroless images to ship the binary.\nAnother thing when shipping is that the binary can be used on a different architecture than it was built on (for example, you build it on an amd64 PC, but will run it on a arm64 server). There are two things you can do here:\nuse emulation (e.g. QEMU) to build the image use cross-compilation Emulation usually results in really slow build times, so I avoid it if I can. Luckily, Go has pretty great support for cross-compilation out of the box - you just need to set GOARCH flag when compiling.\nHere\u0026rsquo;s how a minimal Dockerfile for building and shipping a Go binary might look like\nFROM --platform=$BUILDPLATFORM golang:1.23-alpine AS build ARG TARGETPLATFORM COPY go.sum go.mod main.go ./ RUN CGO_ENABLED=0 GOARCH=$(echo $TARGETPLATFORM | cut -d\u0026#39;/\u0026#39; -f2) GOOS=linux go build -o server . FROM gcr.io/distroless/static-debian11 AS base USER nonroot COPY --from=build --chown=nonroot:nonroot /app/server /server ENTRYPOINT [\u0026#34;/server\u0026#34;] Docker requires you to specify the target platform as linux/arm64 or linux/amd64, while Go omits the linux/ prefix, which is why the use of cut is needed.\n","permalink":"http://localhost:1313/bytes/my-go-setup/","summary":"\u003cp\u003eIn this post I\u0026rsquo;ll describe what I use for writing, linting, formatting, shipping, \u0026hellip; \u003cstrong\u003eGo code\u003c/strong\u003e. This is the first in a series of posts where I\u0026rsquo;ll describe my setup in the three languages that I code in: Go (this post), Python and C++.\u003c/p\u003e\n\u003cp\u003eThis one will be the most boring one in the series - Go is the most \u0026ldquo;batteries included\u0026rdquo; language out of the bunch, so there\u0026rsquo;s not much to say beyond \u0026ldquo;I use the default thing that Go/standard library provides\u0026rdquo;.\u003c/p\u003e","title":"My Go setup"}]